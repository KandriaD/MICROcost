import sys
import pandas as pd
import glob
import os
import datetime
from openpyxl import load_workbook
from openpyxl.styles import Font
from openpyxl.utils import get_column_letter

## Note that I can actually create dropdown boxes and even designate fill colors all within openpyxl
##   HOWEVER, they will not carry over to GoogleSheets so there is no point in including them here.
##   But here is how to do it for future reference:
    ## from openpyxl.worksheet.datavalidation import DataValidation
    ### create list and do data validation
        ## Example: list of rooms
            # room_options = ["Room 101", "Room 102", "Room 113", "Room 140"]
            # dv = DataValidation(type="list", formula1=f'"{",".join(room_options)}"', allow_blank=True)

        ## Apply to column (e.g., column H, rows 2 through max_row)
            # ws.add_data_validation(dv)
            # dv.add(f"H2:H{ws.max_row}")

    ## from openpyxl.styles import PatternFill
    ## from openpyxl.formatting.rule import CellIsRule, FormulaRule
    ### store options colors
            # room_colors = {
                # "Room 101": "FFC7CE",  # light red
                # "Room 102": "C6EFCE",  # light green
                # "Room 113": "FFEB9C",  # light yellow
                # "Room 140": "BDD7EE",  # light blue
            # }
    ### Apply conditional formatting for each option
            # for room, color in room_colors.items():
            #     fill = PatternFill(start_color=color, end_color=color, fill_type="solid")
            #     formula = f'$H2="{room}"'  # assuming Storage Room is column H
            #     ws.conditional_formatting.add(f"H2:H{ws.max_row}", FormulaRule(formula=[formula], fill=fill))


# ----------------------------
# Setup paths and imports
# ----------------------------
script_dir = os.path.dirname(os.path.abspath(__file__))
libraries_path = os.path.join(script_dir, "..", "Libraries")
if libraries_path not in sys.path:
    sys.path.append(libraries_path)

import bacteria
import media
import supplies
import antibiotics
import chemicals

special_forms = ["1_ml", "0.5_ml", "1_ul"]


# ----------------------------
# TA assignment rules
# ----------------------------
TA_ASSIGNMENTS = {
    "Emily": {
        "both": ["351L", "140L","463L"],
        "bio_only": ["401L", "461L"]
    },
    "Jenna": {
        "both": ["431L"],
        "sup_only": ["401L", "461L"]
    }
}

# ============================
#   SORT PROFILES FOR SHEETS
# ============================

SORT_PROFILES = {
    "Option1": ["Course", "Category", "Media Used", "Form", "Item/Organism"],
    "Option2": ["Category", "Media Used","Form", "Item/Organism", "Course"],
    "Option3": ["Category", "Course",  "Media Used", "Form", "Item/Organism"],
    "Option4": ["Course", "Category", "Item/Organism", "Media Used", "Form"]
}

TA_SORT_PROFILE = {
    "Emily": "Option3",
    "Jenna": "Option2"
}


def get_prep_ta(course, category):
    """
    Determine which TA should receive this item based on rules.
    Course name is extracted via 'BIOL 351L' or '351L' depending on filename.
    """

    # Extract the course number (handles files like 'BIOL 140L Experiments')
    course_number = "".join([c for c in course if c.isdigit() or c == "L"])

    # Check TA E rules
    if course_number in TA_ASSIGNMENTS["Emily"]["both"]:
        return "Emily"
    if course_number in TA_ASSIGNMENTS["Emily"]["bio_only"] and category == "Biological":
        return "Emily"

    # Check TA J rules
    if course_number in TA_ASSIGNMENTS["Jenna"]["both"]:
        return "Jenna"
    if course_number in TA_ASSIGNMENTS["Jenna"]["sup_only"] and category != "Biological":
        return "Jenna"

    return None  # no TA for this item



# === Week Parsing ===
def parse_week_string(week_str):
    import datetime, re
    
    if not isinstance(week_str, str) or not week_str.strip():
        return datetime.datetime.max

    # Normalize month names
    week_str = week_str.replace("Sept", "Sep")

    # Ensure there's a space between month and day (e.g., "Sep30" â†’ "Sep 30")
    week_str = re.sub(r'([A-Za-z]+)(\d)', r'\1 \2', week_str)

    try:
        first_part = week_str.split("-")[0].strip()
        return datetime.datetime.strptime(first_part + " 2025", "%b %d %Y")
    except Exception:
        return datetime.datetime.max

def load_course_info(course_df):
    return {
        "students": int(course_df.loc[0, "Students"]),
        "sections": int(course_df.loc[0, "Sections"]),
        "groups": int(course_df.loc[0, "Groups"]),
        "rooms": course_df.loc[0, "Rooms"].split(", ")
    }

def calculate_total_qty(quantity, dist_type, course_info, form=None):
    multiplier = {
        "Per Student": course_info["students"],
        "Per Pair": course_info["students"] // 2,
        "Per Group": course_info["groups"],
        "Per Table": sum(5 if room.strip() == "113" else 6 for room in course_info['rooms']),
        "Per Section": course_info["sections"],
        "Per Room": len(course_info["rooms"]),
        "Per Course": 1
    }.get(dist_type, 1)

    if form in special_forms:
        return multiplier
    else:
        return quantity * multiplier

def get_all_weeks():
    folder_path = r"C:\Users\Kandriad\Desktop\ExpFiles"
    pattern = os.path.join(folder_path, "*Experiments.xlsx")
    experiment_files = glob.glob(pattern)

    all_weeks = set()
    for file in experiment_files:
        xls = pd.ExcelFile(file)
        schedule_df = xls.parse("ExperimentIndex")
        schedule_df.columns = schedule_df.columns.str.strip()
        all_weeks.update(schedule_df["Week"].unique())

    print(f"Found weeks:{all_weeks}")  

    # Sort weeks using parse_week_string
    return sorted(all_weeks, key=parse_week_string)


# ============================================
#         MAIN: GATHER WEEKLY ITEMS
# ============================================
def gather_weekly_needs(week_number):

    folder_path = r"C:\Users\Kandriad\Desktop\ExpFiles"
    pattern = os.path.join(folder_path, "*Experiments.xlsx")
    experiment_files = glob.glob(pattern)

    weekly_items = []  # <-- Collect everything here (no filtering yet)

    for file in experiment_files:
        course_name = os.path.basename(file).replace("Experiments.xlsx", "").strip()
        xls = pd.ExcelFile(file)

        # Load course info
        course_df = xls.parse("CourseInfo")
        course_info = load_course_info(course_df)

        # Load weekly sheet map
        schedule_df = xls.parse("ExperimentIndex")
        schedule_df.columns = schedule_df.columns.str.strip()

        week_exps = schedule_df[schedule_df["Week"] == week_number]    

        for _, row in week_exps.iterrows():

            sheet_name = str(row["SheetName"])
            if sheet_name.endswith('.0'):
                sheet_name = sheet_name[:-2]

            if sheet_name not in xls.sheet_names:
                print(f"Missing sheet: {sheet_name} in {file}")
                continue

            exp_df = xls.parse(sheet_name)
            exp_df.columns = exp_df.columns.str.strip()

            for _, entry in exp_df.iterrows():

                category = str(entry.get("Category", "")).strip()
                if not category or category.lower() == "nan":
                    continue

                item_name = entry.get("Item/Organism")
                if pd.isna(item_name) and category == "Uninoculated Media":
                    item_name = entry.get("Media Used")

                name = str(item_name).strip() if item_name is not None else ""
                media_used = entry.get("Media Used")
                form_raw = entry.get("Form")
                form = str(form_raw).strip().replace(" ", "_") if form_raw else ""
                if form in special_forms:
                    quantity = entry.get("Volume", 0)
                else:
                    quantity = entry.get("Quantity", 0)
                dist_type = str(entry.get("DistributionType", "")).strip().title()

                try:
                    total_qty = calculate_total_qty(quantity, dist_type, course_info, form)
                except Exception as e:
                    print(f"Error calculating qty for {course_name} {category} {name}: {e}")
                    continue

                # Add item
                weekly_items.append({
                    "Week": week_number,
                    "Course": course_name,
                    "Category": category,
                    "Item/Organism": name,
                    "Media Used": media_used,
                    "Form": form,
                    "Total Quantity": total_qty,
                    "Notes": entry.get("Notes", ""),
                    "Storage Room": "", 
                    "Storage Loc.": ""
                })

    return weekly_items

# ============================================
#          EXPORT BY PREP TA + FORMATTING
# ============================================
def export_all_weeks_by_prep_ta(filename):
    
    all_weeks = get_all_weeks()
    all_records = []

    for week in all_weeks:
        items = gather_weekly_needs(week)

        for rec in items:
            ta = get_prep_ta(rec["Course"], rec["Category"])
            rec["PrepTA"] = ta or "Unassigned"

            if ta:
                all_records.append(rec)

    # Build DataFrame (may be empty)
    df = pd.DataFrame(all_records)

    # If df is empty, we still want to create sheets with headers
    expected_columns = [
        "Week", "Course", "Category", "Item/Organism", "Media Used",
        "Form", "Total Quantity", "Notes", "Storage Room", "Storage Loc.", "PrepTA"
    ]

    # Convert Week column to datetime for proper sorting (only if present)
    if not df.empty and "Week" in df.columns:
        df["Week_dt"] = df["Week"].apply(lambda x: parse_week_string(str(x)))

    # # Sort using the new datetime column if possible
    # sort_order = ["Week_dt", "Category", "Course", "Media Used", "Form", "Item/Organism"]
    # if not df.empty and all(col in df.columns for col in sort_order):
    #     df = df.sort_values(by=sort_order, ascending=True)

    # If Week_dt was added, drop it now
    if "Week_dt" in df.columns:
        df = df.drop(columns=["Week_dt"])

    # --- Write file (NO manual save here) ---
    with pd.ExcelWriter(filename, engine="openpyxl") as writer:

        # If df is empty, create empty sheets with headers for each TA to avoid saving problems
        if df.empty:
            headers_df = pd.DataFrame(columns=expected_columns)
            for ta in ["Emily", "Jenna"]:
                headers_df.to_excel(writer, sheet_name=f"TA_{ta}", index=False)
        else:
            # Ensure PrepTA column exists before filtering
            if "PrepTA" not in df.columns:
                df["PrepTA"] = "Unassigned"

            for ta in ["Emily", "Jenna"]:
                df_ta = df[df["PrepTA"] == ta].copy()
                
                sort_profile_name = TA_SORT_PROFILE.get(ta)
                if sort_profile_name:
                    sort_columns = SORT_PROFILES.get(sort_profile_name, [])
                    # Only keep columns that actually exist in df_ta
                    valid_sort_cols = [c for c in sort_columns if c in df_ta.columns]
                    
                    if valid_sort_cols:
                        df_ta = df_ta.sort_values(by=valid_sort_cols, ascending=True)

                if "PrepTA" in df_ta.columns:
                    df_ta = df_ta.drop(columns=["PrepTA"])

                # If TA has no rows, write an empty sheet with headers (to keep structure consistent)
                if df_ta.empty:
                    pd.DataFrame(columns=df.columns).to_excel(writer, sheet_name=f"TA_{ta}", index=False)
                else:
                    df_ta.to_excel(writer, sheet_name=f"TA_{ta}", index=False)

    # ------------------------------
    # SAFE Formatting with openpyxl
    # ------------------------------
    from openpyxl import load_workbook
    from openpyxl.styles import Font, Alignment, Border, Side
    from openpyxl.utils import get_column_letter

    thick = Side(border_style="thick", color="000000")

    wb = load_workbook(filename)

    for sheet_name in wb.sheetnames:
        ws = wb[sheet_name]

        # ---------------------
        # Identify columns
        # ---------------------
        col_index = {cell.value: idx+1 for idx, cell in enumerate(ws[1])}

        week_col = col_index.get("Week")
        course_col = col_index.get("Course")
        category_col = col_index.get("Category")
        media_col = col_index.get("Media Used")
        form_col = col_index.get("Form")
        total_col = col_index.get("Total Quantity")
        item_col = col_index.get("Item/Organism")
        notes_col = col_index.get("Notes")

        center_cols = [
            week_col, course_col, category_col,
            media_col, form_col, total_col
        ]
        center_cols = [c for c in center_cols if c]

        # ---------------------------------------
        # BASE FORMATTING: vertical center + wrap
        # ---------------------------------------
        for row in ws.iter_rows():
            for cell in row:
                cell.font = Font(name="Consolas", size=11)
                cell.alignment = Alignment(vertical="center", wrap_text=True)

        # ---------------------------------------
        # Italicize Item/Organism when Biological
        # ---------------------------------------
        if category_col and item_col:
            for row in ws.iter_rows(min_row=2, max_row=ws.max_row):
                category_cell = row[category_col - 1]
                item_cell = row[item_col - 1]

                category_val = str(category_cell.value).strip().lower() if category_cell.value else ""
                if category_val == "biological":
                    # preserve existing font properties, just set italic=True
                    current_font = item_cell.font or Font(name="Consolas", size=11)
                    item_cell.font = Font(
                        name=current_font.name or "Consolas",
                        size=current_font.sz or 11,
                        bold=current_font.bold,
                        italic=True
                    )


        # ---------------------------------------
        # HEADER ROW: bold + center + thick underline
        # ---------------------------------------
        for cell in ws[1]:
            cell.font = Font(name="Consolas", size=11, bold=True)
            cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
            cell.border = Border(bottom=thick)

        # ---------------------------------------
        # First column: bold + thick right border
        # ---------------------------------------
        for r in range(2, ws.max_row + 1):
            cell = ws.cell(row=r, column=1)
            cell.font = Font(name="Consolas", size=11, bold=True)
            cell.border = Border(right=thick)

        # ---------------------------------------
        # Center align selected columns
        # ---------------------------------------
        for r in range(2, ws.max_row + 1):
            for col in center_cols:
                ws.cell(row=r, column=col).alignment = Alignment(
                    horizontal="center", vertical="center", wrap_text=True
                )

        # ---------------------------------------
        # Exption columns with fixed width
        # ---------------------------------------
        if notes_col:
            ws.column_dimensions[get_column_letter(notes_col)].width = 70
        
        if form_col:
            ws.column_dimensions[get_column_letter(form_col)].width = 16
        
        if media_col:
            ws.column_dimensions[get_column_letter(media_col)].width = 17
        
        if total_col:
            ws.column_dimensions[get_column_letter(total_col)].width = 10
            
        # ---------------------------------------
        # Auto-fit other columns 
        # ---------------------------------------
        for col_cells in ws.columns:
            col_letter = get_column_letter(col_cells[0].column)
            if notes_col and col_cells[0].column == notes_col:
                continue
            if form_col and col_cells[0].column == form_col:
                continue
            if media_col and col_cells[0].column == media_col:
                continue
            if total_col and col_cells[0].column == total_col:
                continue

            max_len = 0
            for c in col_cells:
                if c.value:
                    max_len = max(max_len, len(str(c.value)))
            ws.column_dimensions[col_letter].width = max(max_len + 2, 10)

        # ---------------------------------------
        # SAFE Week merging
        # ---------------------------------------
        if week_col:
            start = 2
            while start <= ws.max_row:
                start_val = ws.cell(row=start, column=week_col).value
                end = start
                while end + 1 <= ws.max_row and ws.cell(row=end + 1, column=week_col).value == start_val:
                    end += 1

                if end > start:
                    ws.merge_cells(
                        start_row=start, end_row=end,
                        start_column=week_col, end_column=week_col
                    )

                start = end + 1

    # -------------------------------------------------------
    # Remove existing output file if it exists (overwrite)
    # -------------------------------------------------------
    if os.path.exists(filename):
        try:
            os.remove(filename)
        except Exception as e:
            print(f"Could not delete existing file: {e}")
            return
        
    wb.save(filename)
    print(f"Created {filename} successfully with full formatting.")

export_all_weeks_by_prep_ta("Spring26PrepTANeeds.xlsx")

